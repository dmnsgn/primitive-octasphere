<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>
      primitive-octasphere by Damien Seguin (https://github.com/dmnsgn)
    </title>
    <style>
      :root {
        --color-dark: #404040;
        --color-light: #f2f2f2;
        --color-accent: #fd5e62;
      }

      body {
        margin: 0;
        overscroll-behavior: none;
        font-family: sans-serif;
        color: var(--color-light);
        background-color: var(--color-dark);
      }

      main {
        position: absolute;
        width: 100%;
        height: 100%;
      }
      h1 {
        position: absolute;
        top: 0;
        left: 20px;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>primitive-octasphere</h1>
    </main>
    <script async src="web_modules/es-module-shims.js" type="module"></script>
    <script src="web_modules/import-map.json" type="importmap"></script>

    <script type="module">
      import createOctasphere from "./index.js";

      import { mat4 } from "gl-matrix";
      import AsyncPreloader from "async-preloader";
      import createContext from "pex-context";
      import { PerspectiveCamera, Controls } from "cameras";
      import dat from "dat.gui";

      const gui = new dat.GUI();
      const modeOptions = ["texture", "normal", "flat-shaded", "uv"];
      const options = {
        mode: "texture",
      };
      gui.add(options, "mode", modeOptions);

      // Geometry
      const geometry = createOctasphere();

      console.log("geometry", geometry);

      // Render
      const canvas = document.createElement("canvas");
      document.querySelector("main").appendChild(canvas);
      const ctx = createContext({ canvas });

      const camera = new PerspectiveCamera({ position: [1.5, 1.5, 1.5] });
      const controls = new Controls({ element: canvas, camera });

      // Events
      const onResize = () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        canvas.width = width;
        canvas.height = height;
      };

      const drawLines = {
        pipeline: ctx.pipeline({
          vert: /* glsl */ `
attribute vec3 aPosition;
attribute vec4 aColor;

uniform mat4 uProjectionMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uModelMatrix;

varying vec4 vColor;

void main () {
  vColor = aColor;
  vec3 position = aPosition;
  gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);
}`,
          frag: /* glsl */ `
precision highp float;

varying vec4 vColor;

void main () {
  gl_FragColor = vColor;
}`,
          depthTest: true,
          primitive: ctx.Primitive.Lines,
        }),
        attributes: {
          aPosition: ctx.vertexBuffer([
            [0, 0, 0],
            [1, 0, 0],
            [0, 0, 0],
            [0, 1, 0],
            [0, 0, 0],
            [0, 0, 1],
          ]),
          aColor: ctx.vertexBuffer([
            [1, 0, 0, 1],
            [1, 0.5, 0.5, 1],
            [0, 1, 0, 1],
            [0.5, 1, 0.5, 1],
            [0, 0, 1, 1],
            [0.5, 0.5, 1, 1],
          ]),
        },
        indices: ctx.indexBuffer([
          [0, 1],
          [2, 3],
          [4, 5],
        ]),
        uniforms: {
          uProjectionMatrix: null,
          uViewMatrix: null,
          uModelMatrix: mat4.create(),
        },
      };

      const drawCmd = {
        pipeline: ctx.pipeline({
          vert: /* glsl */ `
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aUv;

uniform mat4 uProjectionMatrix;
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uInverseViewMatrix;

varying vec3 vPositionWorld;
varying vec3 vPositionView;
varying vec3 vNormal;
varying vec2 vUv;

void main() {
  vNormal = aNormal;
  vUv = aUv;

  vPositionWorld = (uModelMatrix * vec4(aPosition, 1.0)).xyz;
  vPositionView = (uViewMatrix * vec4(vPositionWorld, 1.0)).xyz;

  gl_Position = uProjectionMatrix * vec4(vPositionView, 1.0);
}
`,
          frag: /* glsl */ `
#extension GL_OES_standard_derivatives : enable
precision highp float;

varying vec3 vNormal;
varying vec2 vUv;

uniform sampler2D uBaseColorMap;
uniform float uMode;

varying vec3 vPositionWorld;

void main() {
  if (uMode == 0.0) gl_FragColor = texture2D(uBaseColorMap, vUv);
  if (uMode == 1.0) gl_FragColor = vec4(vNormal * 0.5 + 0.5, 1.0);
  if (uMode == 2.0) {
    vec3 fdx = vec3(dFdx(vPositionWorld.x), dFdx(vPositionWorld.y), dFdx(vPositionWorld.z));
    vec3 fdy = vec3(dFdy(vPositionWorld.x), dFdy(vPositionWorld.y), dFdy(vPositionWorld.z));
    vec3 normal = normalize(cross(fdx, fdy));
    gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);
  }
  if (uMode == 3.0) gl_FragColor = vec4(vUv.xy, 0.0, 1.0);
}
`,
          depthTest: true,
          primitive: ctx.Primitive.Triangles,
        }),
        attributes: {
          aPosition: ctx.vertexBuffer(geometry.positions),
          aNormal: ctx.vertexBuffer(geometry.normals),
          aUv: ctx.vertexBuffer(geometry.uvs),
        },
        indices: ctx.indexBuffer(geometry.cells),
        uniforms: {
          uProjectionMatrix: camera.projectionMatrix,
          uViewMatrix: camera.viewMatrix,
          uModelMatrix: mat4.create(),
          uBaseColorMap: null,
        },
      };

      const clearCmd = {
        pass: ctx.pass({
          clearColor: [0.05, 0.05, 0.05, 1],
        }),
      };

      (async () => {
        const uvMap = ctx.texture2D({
          width: 1024,
          height: 1024,
          pixelFormat: ctx.PixelFormat.RGBA8,
          encoding: ctx.Encoding.Linear,
          min: ctx.Filter.Linear,
          mag: ctx.Filter.Linear,
          wrap: ctx.Wrap.Repeat,
          encoding: ctx.Encoding.SRGB,
          flipY: true,
          data: await AsyncPreloader.loadImage({
            src: "examples/uv.jpg",
          }),
        });
        drawCmd.uniforms.uBaseColorMap = uvMap;

        onResize();

        ctx.frame(() => {
          ctx.submit(clearCmd);

          controls.update();
          camera.position = controls.position;
          camera.target = controls.target;
          camera.update();

          drawLines.uniforms.uProjectionMatrix = camera.projectionMatrix;
          drawLines.uniforms.uViewMatrix = camera.viewMatrix;

          ctx.submit(drawLines);

          ctx.submit(drawCmd, {
            uniforms: {
              uMode: modeOptions.findIndex((o) => o === options.mode),
            },
          });
        });

        window.addEventListener("resize", onResize);
      })();
    </script>
  </body>
</html>
